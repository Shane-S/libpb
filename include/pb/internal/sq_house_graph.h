#ifndef PB_SQ_HOUSE_GRAPH_H
#define PB_SQ_HOUSE_GRAPH_H

#include <stdlib.h>
#include <pb/sq_house.h>
#include <pb/util/graph/graph.h>
#include <pb/util/hashmap/hashmap.h>
#include <pb/util/vector/vector.h>

/**
 * Defines a connection to a neighbouring room.
 */
typedef struct {
    pb_room* room;
    pb_room* neighbour;
    pb_point2D overlap_start;
    pb_point2D overlap_end;
    int wall;
    int can_connect; /* Whether these rooms are allowed to connect as per the room specs */
    int has_door; /* True if can_connect and there's space for a door (house_spec.door_size) */
} pb_sq_house_room_conn;

/**
 * Determines which wall (if any) is shared by room1 and room2.
 *
 * @param room1 The first room to check for a shared wall.
 * @param room2 The second room to check for a shared wall.
 *
 * @return The appropriate value from the side enum if there is a shared wall,
 *         -1 if there are no shared walls between the rooms.
 */
int pb_sq_house_get_shared_wall(pb_room* room1, pb_room* room2);

/**
 * Gets the overlap between the shared walls in room1 and room2.
 *
 * Note that end-start in the dimension of overlap will always be increasing.
 * E.g. if the top wall intersected, end.x - start.x will always be >= 0.
 *
 * @param room1 The first room (must be the same as room1 in pb_sq_house_shared_wall).
 * @param room2 The second room (must be the same as room2 in pb_sq_house_shared_wall).
 * @param wall  The wall shared between the rooms (as per pb_sq_house_shared_wall).
 *              Must be [1, 4]; if it's outside this range, the function returns without modifying
 *              its arguments.
 * @param start Holds the start point of overlap.
 * @param end   Holds the end point of overlap.
 */
void pb_sq_house_get_wall_overlap(pb_room const* room1, pb_room const* room2, int wall, pb_point2D* start, pb_point2D* end);

/**
 * Generates a connectivity graph between the rooms of a given floor.
 *
 * The edges in the graph are of type pb_sq_house_room_conn and indicate whether these rooms
 * could be connected by a door (based on their room_specs).
 *
 * Vertices are identified by the room they store; call pb_graph_get_vertex with a pointer to
 * a room as the vert_id to get its corresponding vertex. That vertex's data member will also
 * be set to the room pointer (vertex->data == vert_id).
 *
 * @param room_specs The map containing room specifications for this house.
 * @param floor      The floor for which the connectivity graph will be generated.
 * @return A graph containing the rooms' connections.
 */
pb_graph* pb_sq_house_generate_floor_graph(pb_sq_house_house_spec* house_spec, pb_hashmap* room_specs, pb_floor* floor);

/**
 * Given a floor graph generated by pb_sq_house_generate_floor_graph, finds any rooms that
 * don't have any adjacent rooms to which they can connect.
 *
 * Note that if a room says that it can connect to a neighbour, but the neighbour can't
 * connect to that room, both rooms ARE considered connected.
 *
 * @param floor_graph The floor connectivity graph.
 * @param floor       The floor being processed.
 * @return A pb_hashmap containing the list of disconnected rooms. The vert_id for the room is the key,
 *         and the room pointer (which is also the vert_id, but whatever) is the value. Note that the
 *         first room on the floor (the room connecting to outside on the first floor and the first set
 *         of stairs on every other floor) will never be in this list. Returns NULL on failure.
 */
pb_hashmap* pb_sq_house_find_disconnected_rooms(pb_graph* floor_graph, pb_floor* floor);

/**
 * Creates a graph of the internal points and edges (edges that don't run along the outside of the house).
 *
 * Each edge in the graph contains a pointer to a room connection which holds the rooms on either side of the edge.
 * The key for a given vertex is the pb_point2D it holds (by value, so any point "equal" (as defined by pb_point_eq)
 * to that point works).
 *
 * @param floor_graph The floor graph generated by pb_sq_house_generate_floor_graph.
 * @return A graph of the house's internal points.
 */
pb_graph* pb_sq_house_generate_internal_graph(pb_graph* floor_graph);

/**
 * Creates a series of hallways to make any disconnected rooms accessible.
 *
 * @param f              The floor being processed.
 * @param floor_graph    The graph representing the rooms on the floor and their connections.
 * @param internal_graph The graph containing the floor's internal points.
 * @param disconnected   The set of disconnected rooms.
 * @return               A pb_vector of pb_vectors. Each vector contains a list of edges in the internal graph which
 *                       together represent a hallway.
 */
pb_vector* pb_sq_house_get_hallways(pb_floor* f, pb_graph* floor_graph, pb_graph* internal_graph,
                                    pb_hashmap* disconnected);

/**
 * Places hallways discovered by pb_sq_house_get_hallways in the floor graph.
 *
 * @param floor          The floor to which the hallways will be added.
 * @param hspec          The specifications for this house.
 * @param room_specs     The set of room specifications for rooms in this house.
 * @param floor_graph    The floor graph representing the given floor.
 * @param internal_graph The graph of the floor's internal points.
 * @param hallways       The list of hallways returned by pb_sq_house_get_hallways.
 *
 * @return 0 on succcess, -1 on failure.
 */
int pb_sq_house_place_hallways(pb_floor* floor, pb_sq_house_house_spec* hspec, pb_hashmap* room_specs,
                               pb_graph* floor_graph, pb_graph* internal_graph, pb_vector* hallways);

#endif /* PB_SQ_HOUSE_GRAPH_H */
